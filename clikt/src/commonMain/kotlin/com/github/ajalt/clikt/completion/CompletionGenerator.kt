package com.github.ajalt.clikt.completion

import com.github.ajalt.clikt.completion.CompletionCandidates.Custom.ShellType
import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.parameters.options.Option
import com.github.ajalt.clikt.parameters.options.OptionWithValues

object CompletionGenerator {

    fun generateBashCompletion(command: CliktCommand): String {
        return generateBashOrZshCompletion(command, zsh = false)
    }

    fun generateZshCompletion(command: CliktCommand): String {
        return generateBashOrZshCompletion(command, zsh = true)
    }

    fun generateFishCompletion(command: CliktCommand): String {
        if (!command.hasFishCompletionRequirements) return ""
        return generateFishCompletionForCommand(
                command = command,
        )
    }

    private fun generateBashOrZshCompletion(command: CliktCommand, zsh: Boolean): String {
        val commandName = command.commandName
        val (isTopLevel, funcName) = commandCompletionFuncName(command)
        val options = command._options
                .filterNot { it.hidden }
                .map { Triple(it.allNames, it.completionCandidates, it.nvalues) }
        val arguments = command._arguments.map { it.name to it.completionCandidates }
        val subcommands = command._subcommands.map { it.commandName }
        val fixedArgNameArray = command._arguments
                .takeWhile { it.nvalues > 0 }
                .flatMap { arg -> (1..arg.nvalues).map { "'${arg.name}'" } }
                .joinToString(" ")
        val varargName = command._arguments.find { it.nvalues < 0 }?.name.orEmpty()
        val paramsWithCandidates = (options.map { o -> o.first.maxByOrNull { it.length }!! to o.second } + arguments)

        if (options.isEmpty() && subcommands.isEmpty() && arguments.isEmpty()) return ""

        return buildString {
            if (isTopLevel) {
                append("""
                |#!/usr/bin/env ${if (zsh) "zsh" else "bash"}
                |# Command completion for $commandName
                |# Generated by Clikt
                |
                |
                """.trimMargin())

                if (zsh) {
                    append("""
                    |autoload bashcompinit
                    |bashcompinit
                    |
                    |
                    """.trimMargin())
                }

                append("""
                |__skip_opt_eq() {
                |    # this takes advantage of the fact that bash functions can write to local
                |    # variables in their callers
                |    (( i = i + 1 ))
                |    if [[ "${'$'}{COMP_WORDS[${'$'}i]}" == '=' ]]; then
                |          (( i = i + 1 ))
                |    fi
                |}
                |
                """.trimMargin())
            }

            // Generate functions for any custom completions
            for ((name, candidate) in paramsWithCandidates) {
                val body = (candidate as? CompletionCandidates.Custom)?.generator?.invoke(ShellType.BASH)
                        ?: continue
                val indentedBody = body.trimIndent().prependIndent("  ")
                append("""
                |
                |${customParamCompletionName(funcName, name)}() {
                |$indentedBody
                |}
                |
                """.trimMargin())
            }

            // Generate the main completion function for this command
            append("""
            |
            |$funcName() {
            |  local i=${if (isTopLevel) "1" else "$" + "1"}
            |  local in_param=''
            |  local fixed_arg_names=($fixedArgNameArray)
            |  local vararg_name='$varargName'
            |  local can_parse_options=1
            |
            |  while [[ ${'$'}{i} -lt ${'$'}COMP_CWORD ]]; do
            |    if [[ ${'$'}{can_parse_options} -eq 1 ]]; then
            |      case "${'$'}{COMP_WORDS[${'$'}i]}" in
            |        --)
            |          can_parse_options=0
            |          (( i = i + 1 ));
            |          continue
            |          ;;
            |
            """.trimMargin())

            for ((names, _, nargs) in options) {
                append("        ")
                names.joinTo(this, "|", postfix = ")\n")
                append("          __skip_opt_eq\n")
                if (nargs > 0) {
                    append("          (( i = i + $nargs ))\n")
                    append("          [[ \${i} -gt COMP_CWORD ]] && in_param='${names.maxByOrNull { it.length }}' || in_param=''\n")
                } else {
                    append("          in_param=''\n")
                }

                append("""
                |          continue
                |          ;;
                |
                """.trimMargin())
            }

            append("""
            |      esac
            |    fi
            |    case "${'$'}{COMP_WORDS[${'$'}i]}" in
            |
            """.trimMargin())

            for ((name, toks) in command.aliases()) {
                append("""
                |      $name)
                |        (( i = i + 1 ))
                |        COMP_WORDS=( "${'$'}{COMP_WORDS[@]:0:i}"
                """.trimMargin())
                toks.joinTo(this, " ", prefix = " ") { "'$it'" }
                append(""" "${'$'}{COMP_WORDS[@]:${'$'}{i}}" )""").append("\n")
                append("        (( COMP_CWORD = COMP_CWORD + ${toks.size} ))\n")

                if (!command.currentContext.allowInterspersedArgs) {
                    append("        can_parse_options=0\n")
                }

                append("        ;;\n")
            }


            for (sub in command._subcommands) {
                append("""
                |      ${sub.commandName})
                |        ${commandCompletionFuncName(sub).second} ${'$'}(( i + 1 ))
                |        return
                |        ;;
                |
                """.trimMargin())
            }

            append("""
            |      *)
            |        (( i = i + 1 ))
            |        # drop the head of the array
            |        fixed_arg_names=("${'$'}{fixed_arg_names[@]:1}")
            |
            """.trimMargin())

            if (!command.currentContext.allowInterspersedArgs) {
                append("        can_parse_options=0\n")
            }

            append("""
            |        ;;
            |    esac
            |  done
            |  local word="${'$'}{COMP_WORDS[${'$'}COMP_CWORD]}"
            |
            """.trimMargin())

            if (options.isNotEmpty()) {
                val prefixChars = options.flatMap { it.first }
                        .mapTo(mutableSetOf()) { it.first().toString() }
                        .joinToString("")
                append("""
                |  if [[ "${"$"}{word}" =~ ^[$prefixChars] ]]; then
                |    COMPREPLY=(${'$'}(compgen -W '
                """.trimMargin())
                options.flatMap { it.first }.joinTo(this, " ")
                append("""' -- "${"$"}{word}"))
                |    return
                |  fi
                |
                 """.trimMargin())
            }

            append("""
            |
            |  # We're either at an option's value, or the first remaining fixed size
            |  # arg, or the vararg if there are no fixed args left
            |  [[ -z "${"$"}{in_param}" ]] && in_param=${"$"}{fixed_arg_names[0]}
            |  [[ -z "${"$"}{in_param}" ]] && in_param=${"$"}{vararg_name}
            |
            |  case "${"$"}{in_param}" in
            |
            """.trimMargin())

            for ((name, completion) in paramsWithCandidates) {
                append("""
                |    $name)
                |
                """.trimMargin())
                when (completion) {
                    CompletionCandidates.None -> {
                    }
                    CompletionCandidates.Path -> {
                        append("       COMPREPLY=(\$(compgen -o default -- \"\${word}\"))\n")
                    }
                    CompletionCandidates.Hostname -> {
                        append("       COMPREPLY=(\$(compgen -A hostname -- \"\${word}\"))\n")
                    }
                    CompletionCandidates.Username -> {
                        append("       COMPREPLY=(\$(compgen -A user -- \"\${word}\"))\n")
                    }
                    is CompletionCandidates.Fixed -> {
                        append("      COMPREPLY=(\$(compgen -W '")
                        completion.candidates.joinTo(this, " ")
                        append("' -- \"\${word}\"))\n")
                    }
                    is CompletionCandidates.Custom -> {
                        if (completion.generator(ShellType.BASH) != null) {
                            // redirect stderr to /dev/null, because bash prints a warning that
                            // "compgen -F might not do what you expect"
                            append("       COMPREPLY=(\$(compgen -F ${customParamCompletionName(funcName, name)} 2>/dev/null))\n")
                        }
                    }
                }

                append("      ;;\n")
            }

            if (subcommands.isNotEmpty()) {
                append("""
                |    *)
                |      COMPREPLY=(${"$"}(compgen -W '
                """.trimMargin())
                subcommands.joinTo(this, " ")
                append("""' -- "${"$"}{word}"))
                |      ;;
                |
                """.trimMargin())
            }

            append("""
            |  esac
            |}
            |
            """.trimMargin())

            for (subcommand in command._subcommands) {
                append(generateBashOrZshCompletion(subcommand, zsh))
            }

            if (isTopLevel) {
                append("\ncomplete -F $funcName $commandName")
            }
        }
    }

    private fun commandCompletionFuncName(command: CliktCommand): Pair<Boolean, String> {
        val ancestors = generateSequence(command.currentContext) { it.parent }
                .map { it.command.commandName }
                .toList().asReversed()
        val isTopLevel = ancestors.size == 1
        val funcName = ancestors.joinToString("_", prefix = "_").replace('-', '_')
        return isTopLevel to funcName
    }

    private fun customParamCompletionName(commandFuncName: String, name: String): String {
        return "_${commandFuncName}_complete_${Regex("[^a-zA-Z0-9]").replace(name, "_")}"
    }

    private fun generateFishCompletionForCommand(command: CliktCommand): String = buildString {
        val parentCommandName = command.currentContext.parentNames().lastOrNull()
        val rootCommandName = command.currentContext.commandNameWithParents().first()
        val isTopLevel = parentCommandName == null
        val commandName = command.commandName
        val options = command._options.filterNot { it.hidden }
        val arguments = command._arguments
        val subcommands = command._subcommands
        val hasSubcommands = subcommands.isNotEmpty()
        val subcommandsVarName = command.currentContext.commandNameWithParents()
                .joinToString("_") { it.replace(Regex("\\W"), "_") }
        val parentSubcommandsVarName = when {
            isTopLevel -> subcommandsVarName
            else -> command.currentContext.parentNames()
                    .joinToString("_") { it.replace(Regex("\\W"), "_") }
        }

        if (isTopLevel) {
            appendLine("""
                |# Command completion for $commandName
                |# Generated by Clikt
            """.trimMargin())
        }

        if (hasSubcommands || !isTopLevel) {
            appendLine("\n\n### Setup for $commandName")
        }

        if (hasSubcommands) {
            val subcommandsStr = subcommands.joinToString(" ") { it.commandName }
            appendLine("set -l $subcommandsVarName '$subcommandsStr'")
        }

        if (!isTopLevel) {
            append("complete -c $rootCommandName -f ")

            if (rootCommandName == parentCommandName) {
                append("-n __fish_use_subcommand ")
            } else {
                append("-n \"__fish_seen_subcommand_from $parentCommandName; and not __fish_seen_subcommand_from \$$parentSubcommandsVarName\" ")
            }

            append("-a $commandName ")

            val help = command.commandHelp.replace("'", "\\'")
            if (help.isNotBlank()) {
                append("-d '${help}'")
            }

            appendLine()
        }

        if (options.any { o -> o.allNames.any { it.isValidFishCompletionOption } }) {
            appendLine("\n## Options for $commandName")
        }

        for (option in options) {
            val names = option.allNames.filter { it.isValidFishCompletionOption }
            if (names.isEmpty()) {
                continue
            }

            appendCompleteCall(rootCommandName, isTopLevel, hasSubcommands, commandName)

            for (name in names) {
                append(' ')
                when {
                    name.startsWith("--") -> append("-l ")
                    name.length == 2 -> append("-s ")
                    else -> append("-o ")
                }
                append(name.trimStart('-'))
            }

            if (option is OptionWithValues<*, *, *>) {
                append(" -r")
            }

            appendParamCompletion(option.completionCandidates)
            appendHelp(option.optionHelp)
            appendLine()
        }

        if (arguments.isNotEmpty()) {
            appendLine("\n## Arguments for $commandName")
        }

        for (argument in arguments) {
            appendCompleteCall(rootCommandName, isTopLevel, hasSubcommands, commandName)
            appendParamCompletion(argument.completionCandidates)
            appendHelp(argument.argumentHelp)
            appendLine()
        }

        for (subcommand in subcommands) {
            append(generateFishCompletionForCommand(
                    command = subcommand
            ))
        }
    }

    private fun StringBuilder.appendCompleteCall(
            rootCommandName: String,
            isTopLevel: Boolean,
            hasSubcommands: Boolean,
            commandName: String
    ) {
        append("complete -c $rootCommandName")

        if (isTopLevel) {
            if (hasSubcommands) {
                append(" -n \"not __fish_seen_subcommand_from \$${commandName}_subcommands\"")
            }
        } else {
            append(" -n \"__fish_seen_subcommand_from $commandName\"")
        }
    }

    private fun StringBuilder.appendHelp(help: String) {
        val h = help.takeWhile { it !in "\r\n" }.replace("'", "\\'")
        if (h.isNotBlank()) {
            append(" -d '$h'")
        }
    }

    private fun StringBuilder.appendParamCompletion(completion: CompletionCandidates) {
        when (completion) {
            is CompletionCandidates.None -> {
            }
            is CompletionCandidates.Path -> {
                append(" -F")
            }
            is CompletionCandidates.Hostname -> {
                append(" -fa \"(__fish_print_hostnames)\"")
            }
            is CompletionCandidates.Username -> {
                append(" -fa \"(__fish_complete_users)\"")
            }
            is CompletionCandidates.Fixed -> {
                completion.candidates.joinTo(this, " ", prefix = " -fa \"", postfix = "\"")
            }
            is CompletionCandidates.Custom -> {
                val customCompletion = completion.generator(ShellType.FISH)
                append(" -fa $customCompletion")
            }
        }
    }

    private val CliktCommand.hasFishCompletionRequirements: Boolean
        get() = _arguments.isNotEmpty()
                || _subcommands.isNotEmpty()
                || _options.flatMap { it.allNames }.any { it.isValidFishCompletionOption }

    private val String.isValidFishCompletionOption: Boolean
        get() = startsWith('-')

    private val Option.allNames get() = names + secondaryNames
}
